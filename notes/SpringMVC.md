### Controller 参数注解

**（1）@RequestParam**

接收GET或POST请求传参中的形如 k1=v1&k2=v2 的参数。

**（2）@RequestBody**

接收请求的 body 中 json 格式的参数。

只可以使用类或map接收单个对象，list接收数组

> GET 方式虽然也可以body传参，但是是不符合规范的，不应该使用

**（3）@ModelAttribute**

接收表格传来的数据

**（4）@RequestAttribute**

自己在controller 处理前通过 `request.setAttribnute(k,v)` 设置的参数





----

下面分别对**EXPLAIN**命令结果的每一列进行说明：

- **select_type**:表示SELECT的类型，常见的取值有：

  | 类型     | 说明                              |
  | -------- | --------------------------------- |
  | SIMPLE   | 简单表，不使用表连接或子查询      |
  | PRIMARY  | 主查询，即外层的查询              |
  | UNION    | UNION中的第二个或者后面的查询语句 |
  | SUBQUERY | 子查询中的第一个                  |

- **table**:输出结果集的表（表别名）

- **type**:表示MySQL在表中找到所需行的方式，或者叫访问类型。常见访问类型如下，从上到下，性能由差到最好：

  | ALL              | 全表扫描                 |
  | ---------------- | ------------------------ |
  | **index**        | **索引全扫描**           |
  | **range**        | **索引范围扫描**         |
  | **ref**          | **非唯一索引扫描**       |
  | **eq_ref**       | **唯一索引扫描**         |
  | **const,system** | **单表最多有一个匹配行** |
  | **NULL**         | **不用扫描表或索引**     |

---

包名或目录名永远用单数



# Actor

Actor是计算机科学领域中的一个并行计算模型，它把actors当做通用的并行计算原语：一个actor对接收到的消息做出响应，进行本地决策，可以创建更多的actor，或者发送更多的消息；同时准备接收下一条消息。

每个Actor都有一个(恰好一个)Mailbox。Mailbox相当于是一个小型的队列，一旦Sender发送消息，就是将该消息入队到Mailbox中。入队的顺序按照消息发送的时间顺序。Mailbox有多种实现，默认为FIFO。但也可以根据优先级考虑出队顺序，实现算法则不相同。

从工程中设计模式角度上看：

- Actor是一种多线程场景下的设计模式.
- 设想一种有状态的模块, 会有多线程调它的写接口. 为了线程安全可能需要在一些地方加锁. 加锁加得粒度大了性能可能有问题, 加细了甚至无锁则变得复杂不容易写对.
- 当有状态模块是一个Actor时, 多线程访问它只能给它发消息，不能直接改变它的状态. 